use crate::error::Result;
use crate::config::{GenerationConfig, TemplateConfig};
use super::{ParsedFile, ParsedModule, LlmDocumenter, DocumentationContext, EnhancementRequest, EnhancementType, ProjectInfo, ArchitectureDetector};
use serde::{Serialize, Deserialize};
use tera::{Tera, Context};
use chrono;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedDoc {
    pub content: String,
    pub metadata: DocMetadata,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocMetadata {
    pub generated_from: String,
    pub last_updated: chrono::DateTime<chrono::Utc>,
    pub content_hash: String,
    pub protected_sections: Vec<String>,
}

pub struct DocGenerator {
    config: GenerationConfig,
    template_config: TemplateConfig,
    tera: Tera,
}

impl DocGenerator {
    pub fn new(config: &GenerationConfig, template_config: &TemplateConfig) -> Result<Self> {
        let mut tera = Tera::new("templates/**/*").unwrap_or_else(|_| {
            let mut t = Tera::default();
            t
        });

        // Add built-in template
        let default_template = r#"---
generated_from: {{ file_path }}
last_updated: {{ last_updated }}
content_hash: {{ content_hash }}
language: {{ language }}
---

# {{ module_name | title }}

{% if llm_enhanced_overview -%}
{{ llm_enhanced_overview }}
{% elif file_docs -%}
{{ file_docs }}
{% else -%}
<!-- PROTECTED: Module Overview -->
Add a description of what this module does and why it exists.
Consider explaining the architectural decisions and design patterns used.
<!-- /PROTECTED -->
{% endif %}

## Public API

{% for module in modules -%}
{% if module.visibility == "public" -%}
### {{ module.name }}

*Type: {{ module.item_type }}*

{% if module.docs -%}
{{ module.docs }}
{% else -%}
*No documentation available*
{% endif %}

{% if module.item_type == "impl" and module.children | length > 0 -%}

#### Methods

{% for method in module.children -%}
{% if method.visibility == "public" -%}
**{{ method.name }}**{% if method.signature %} - `{{ method.signature }}`{% endif %}

{% if method.docs -%}
{{ method.docs }}
{% else -%}
*No documentation available*
{% endif %}

{% endif -%}
{% endfor -%}
{% elif module.signature -%}
```{{ language }}
{{ module.signature }}
```
{% endif %}

{% endif -%}
{% endfor -%}

{% if modules | length == 0 -%}
*No public API detected. This may be a private module or the parser may need enhancement.*
{% endif %}

## Implementation Details

<!-- PROTECTED: Implementation Notes -->
Add notes about implementation decisions, performance considerations,
error handling strategies, or anything else that would be useful
for maintainers.
<!-- /PROTECTED -->

## Testing

<!-- PROTECTED: Testing Strategy -->
Describe the testing approach for this module, including:
- Unit test coverage
- Integration test scenarios  
- Mock strategies
- Performance test requirements
<!-- /PROTECTED -->

---

*This documentation was generated by Codesworth. Protected sections are preserved across regenerations.*"#;

        tera.add_raw_template("default.md", default_template)?;

        Ok(Self {
            config: config.clone(),
            template_config: template_config.clone(),
            tera,
        })
    }

    pub async fn generate(&self, parsed_file: &ParsedFile) -> Result<GeneratedDoc> {
        self.generate_with_llm(parsed_file, None).await
    }

    pub async fn generate_with_llm(&self, parsed_file: &ParsedFile, llm_documenter: Option<&dyn LlmDocumenter>) -> Result<GeneratedDoc> {
        let mut context = Context::new();

        // Add file-level context
        context.insert("file_path", &parsed_file.path.display().to_string());
        context.insert("language", &parsed_file.language);
        context.insert("content_hash", &parsed_file.content_hash);
        context.insert("last_updated", &chrono::Utc::now().to_rfc3339());
        context.insert("modules", &parsed_file.modules);
        context.insert("file_docs", &parsed_file.file_docs);

        // Generate module name from file path
        let module_name = parsed_file.path
            .file_stem()
            .unwrap_or_default()
            .to_string_lossy()
            .to_string();
        context.insert("module_name", &module_name);

        // Add template settings
        for (key, value) in &self.template_config.settings {
            context.insert(key, value);
        }

        // Enhance with LLM if available
        if let Some(llm) = llm_documenter {
            if let Ok(enhanced_content) = self.enhance_with_llm(parsed_file, llm).await {
                context.insert("llm_enhanced_overview", &enhanced_content);
            }
        }

        let content = self.tera.render("default.md", &context)?;

        Ok(GeneratedDoc {
            content,
            metadata: DocMetadata {
                generated_from: parsed_file.path.display().to_string(),
                last_updated: chrono::Utc::now(),
                content_hash: parsed_file.content_hash.clone(),
                protected_sections: vec![],
            },
        })
    }

    async fn enhance_with_llm(&self, parsed_file: &ParsedFile, llm: &dyn LlmDocumenter) -> Result<String> {
        let project_info = ProjectInfo {
            name: self.template_config.settings.get("organization")
                .unwrap_or(&"Unknown Project".to_string())
                .clone(),
            description: None,
            language: parsed_file.language.clone(),
            project_type: Some("application".to_string()),
        };

        // Detect architecture context
        let arch_detector = ArchitectureDetector::new();
        let project_root = parsed_file.path.parent()
            .and_then(|p| p.parent()) // Go up from src/ to project root
            .unwrap_or_else(|| std::path::Path::new("."));

        let architecture_docs = arch_detector.detect_architecture(project_root).await
            .unwrap_or(None);

        let context = DocumentationContext {
            file: parsed_file.clone(),
            target_module: None,
            related_files: vec![], // TODO: Pass related files
            project_info,
            architecture_docs,
        };

        let request = EnhancementRequest {
            enhancement_type: EnhancementType::ModuleOverview,
            context,
            current_content: parsed_file.file_docs.clone(),
            focus_areas: vec!["purpose".to_string(), "architecture".to_string(), "integrations".to_string()],
        };

        let response = llm.enhance_documentation(request).await?;
        Ok(response.content)
    }
}